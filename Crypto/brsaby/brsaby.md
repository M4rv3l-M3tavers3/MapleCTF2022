## Challenge

This was a basic RSA challenge with with the following code:

```js 
from Crypto.Util.number import getPrime, bytes_to_long
from secret import FLAG

msg = bytes_to_long(FLAG)
p = getPrime(512)
q = getPrime(512)
N = p*q
e = 0x10001
enc = pow(msg, e, N)
hint = p**4 - q**3

print(f"{N = }")
print(f"{e = }")
print(f"{enc = }")
print(f"{hint = }")

'''
N = 134049493752540418773065530143076126635445393203564220282068096099004424462500237164471467694656029850418188898633676218589793310992660499303428013844428562884017060683631593831476483842609871002334562252352992475614866865974358629573630911411844296034168928705543095499675521713617474013653359243644060206273
e = 65537
enc = 110102068225857249266317472106969433365215711224747391469423595211113736904624336819727052620230568210114877696850912188601083627767033947343144894754967713943008865252845680364312307500261885582194931443807130970738278351511194280306132200450370953028936210150584164591049215506801271155664701637982648648103
hint = 20172108941900018394284473561352944005622395962339433571299361593905788672168045532232800087202397752219344139121724243795336720758440190310585711170413893436453612554118877290447992615675653923905848685604450760355869000618609981902108252359560311702189784994512308860998406787788757988995958832480986292341328962694760728098818022660328680140765730787944534645101122046301434298592063643437213380371824613660631584008711686240103416385845390125711005079231226631612790119628517438076962856020578250598417110996970171029663545716229258911304933901864735285384197017662727621049720992964441567484821110407612560423282
'''
``` 

## The Solution 

To decrypt the flag, we must factor N. This will allow us to compute phi, from which we can decrypt the inverse of e to undo the encryption.

The laziest solution is to let a Computer algebra system (CAS) such as SymPy or SageMath solve this for you.

```js 
from sympy import solve, symbols
p, q = symbols("p q")
P, Q = solve([p**4 - q**3 - hint, p * q - N], [p, q])[0]
```

The `solve` method in SymPy takes a list of equations all equal to zero, and a list of symbols to solve for. We make each equation zero by subtracting the right side from the left. Thereafter we simply decrypt rsa as follows:

```js 
from Crypto.Util.number import long_to_bytes
phi = (P - 1) * (Q - 1)
phi = int(phi)  # P and Q were type sympy.core.numbers.Integer
d = pow(e, -1, phi)
m = pow(enc, d, N)

print(long_to_bytes(m))
```
## Full Code

```js 
from Crypto.Util.number import long_to_bytes
from sympy import solve, symbols

N = 134049493752540418773065530143076126635445393203564220282068096099004424462500237164471467694656029850418188898633676218589793310992660499303428013844428562884017060683631593831476483842609871002334562252352992475614866865974358629573630911411844296034168928705543095499675521713617474013653359243644060206273
e = 65537
enc = 110102068225857249266317472106969433365215711224747391469423595211113736904624336819727052620230568210114877696850912188601083627767033947343144894754967713943008865252845680364312307500261885582194931443807130970738278351511194280306132200450370953028936210150584164591049215506801271155664701637982648648103
hint = 20172108941900018394284473561352944005622395962339433571299361593905788672168045532232800087202397752219344139121724243795336720758440190310585711170413893436453612554118877290447992615675653923905848685604450760355869000618609981902108252359560311702189784994512308860998406787788757988995958832480986292341328962694760728098818022660328680140765730787944534645101122046301434298592063643437213380371824613660631584008711686240103416385845390125711005079231226631612790119628517438076962856020578250598417110996970171029663545716229258911304933901864735285384197017662727621049720992964441567484821110407612560423282

p, q = symbols("p q")
P, Q = solve([p**4 - q**3 - hint, p * q - N], [p, q])[0]

phi = (P - 1) * (Q - 1)
phi = int(phi)  # P and Q were type sympy.core.numbers.Integer
d = pow(e, -1, phi)
m = pow(enc, d, N)

print(long_to_bytes(m))
```
## Solving by Hand
The problem can also be solved by hand, but we will still need to use external tools for the final step. For this example, lets use much smaller primes.

![image](https://user-images.githubusercontent.com/93731698/188599744-2947fb88-c7f6-4332-82c7-1f50975b60b9.png)

We will solve for `q` and substitute it in.

![image](https://user-images.githubusercontent.com/93731698/188599904-c4bcb422-df65-43c5-8f2b-719de90c930c.png)

We rewrite it as a polynomial in standard form.

![image](https://user-images.githubusercontent.com/93731698/188599857-ad82897c-f9e7-4cd5-8d4f-5a29ae5f99e2.png)

We can [plot](https://www.desmos.com/calculator/wtro5wrl9q) this, which reveals the root 17. As an exercise for the reader, try solving for `q` from the hint instead of from `N`, and then substitute it into `N` instead of the hint. How does the solution compare to the given one?
